#Constraints
#Constraint types
NOT NULL (column can not be null) (type C) (name_nn) (can not be null) (many)
UNIQUE (must be unique, but can me many null values) (type U) (name_uk or name_uq) (can be null) (many)
PRIMARY KEY (identifies uniquely each row in the table) (type P) (name_pk) (can not be null) (one)
FOREIGN KEY (references to pk in other table) (type R) (name_fk) (can be null) (many)
CHECK (condition) (type C) (name_chq) (can be null) (many)
Tip: see for types in user_constraints table
Tip: for fk constraint see R_CONSTRAINT_NAME to know column in other table
Tip: constraint name should be unique, so use <table>_pk, <table>_<column>_uk, <table>_<column>_fk, <table>_<column>_chq
Tip: (many) or (one) is how many constraint per table
Tip: only not null and pk constraint are never null
Tip: fk can be null, unique can be null and have many nulls
Tip: unique column can have many null values, nulls are not considered equal to anything, no uniqueness for nulls
Tip: indexes are only pk and fk
Tip: long column can not be used for constraint as pk, unique, fk (only not null constraint can be set)
#Constraint guidelines
* Give name or oracle server gives SYS_Cn name format (can be renamed after)
* Create at table creation time or after
* On column or table level
#Constraint on delete for fk
constraint <constraint_name> foreign key (<this.column>) references <other_table> (<other_table_pk>) on delete cascade
f: if on other table delete row the rows with fk in this table will be removed too
constraint <constraint_name> foreign key (<this.column>) references <other_table> (<other_table_pk>) on delete set null
f: if on other table delete row the rows with fk in this table will be set on fk column to value null, so ref is removed but the row stays in this table
Tip: if no 'on delete' clause then row removal on other table will give error if the refs (fk) to row (pk) in remove operation exits
Tip: other table=main table with pk, this table=dependent table with fk to pk
Tip: you can temporary disable constraints without deleting it
#========================================================
#Table
Alter table when:
add new column (alter table <table_name> add <column_name_and_definition> [ not null default 'my_value']) 
modify column definition exp: size, type, default (alter table <table_name> modify <column_name_and_definition>)
rename column (alter table <table_name> rename column <old_name> to <new_name>;)
set column unused (alter table <table_name> set unused [column] <column_name>)
drop column (alter table <table_name> drop <column_name>)
add new constraint
rename constraint
disable constraint
drop constraint
change table status read-only, read-write (alter table <table_name> read only;) (alter table <table_name> read write;) f: DML are not allowed, DDL are stil allowed like add column, drop table
Tip: the added column will be always the last column, can not specify place
Tip: select * from user_unused_col_tabs;

Rename table: (never do on production)
rename <old_table_name> to <new_table_name>;

Drop table:
drop table <table_name> [purge];
Tip: drop table moves it in recyclebin (select * from user_recyclebin where original_name=<dropped_table_name>)
Tip: drop table with purge option removes it permanently (select * from user_recyclebin where original_name=<dropped_table_name> --output no rows )
#=======================================================
#Dictionary views prefix
user_xxx f: user's view, what is in your schema, what you own
all_xxx  f: expanded user's view (what you can access so your objects and granted objects, has owner column)
dba_xxx  f: db admin's view (what is in everyone's schema, has owner column)
v$xxx    f: dynamic db views, performance releated data
select * from dictionary where table_name='USER_OBJECTS'; 
select * from dictionary; --about 1000 rows (961 rows)
select * from user_catalog; --contains table, view, index, synonym, sequence of user
select * from cat; -- same as from user_catalog
select * from user_objects;
select * from all_objects;
select * from dba_objects; --only for sys or system default
select * from user_tables;
select * from tabs; --same as from user_tables;
select * from user_tab_columns;
select * from all_tables; 
select * from all_tab_columns;
select * from user_constraints;
select * from user_cons_columns;
select * from all_constraints;
select * from all_cons_columns;
select * from user_tab_comments;
select * from user_col_comments;
#=======================================================
